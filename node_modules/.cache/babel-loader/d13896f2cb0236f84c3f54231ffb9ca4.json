{"ast":null,"code":"import { __rest } from 'tslib';\nimport { createBrowserHistory, createHashHistory } from 'history';\nimport React from 'react';\nimport { matchPath as matchPath$1, withRouter, Router } from 'react-router-dom';\nimport { ViewStacks, generateId, IonRoute, ViewLifeCycleManager, StackContext, RouteManagerContext, getConfig, LocationHistory, NavManager } from '@ionic/react';\nimport { Route, matchPath, Router as Router$1 } from 'react-router';\n\nclass IonRouteInner extends React.PureComponent {\n  render() {\n    return React.createElement(Route, {\n      path: this.props.path,\n      exact: this.props.exact,\n      render: this.props.render,\n\n      /**\n       * `computedMatch` is a private API in react-router v5 that\n       * has been removed in v6.\n       *\n       * This needs to be removed when we support v6.\n       *\n       * TODO: FW-647\n       */\n      computedMatch: this.props.computedMatch\n    });\n  }\n\n}\n\nclass ReactRouterViewStack extends ViewStacks {\n  constructor() {\n    super();\n    this.createViewItem = this.createViewItem.bind(this);\n    this.findViewItemByRouteInfo = this.findViewItemByRouteInfo.bind(this);\n    this.findLeavingViewItemByRouteInfo = this.findLeavingViewItemByRouteInfo.bind(this);\n    this.getChildrenToRender = this.getChildrenToRender.bind(this);\n    this.findViewItemByPathname = this.findViewItemByPathname.bind(this);\n  }\n\n  createViewItem(outletId, reactElement, routeInfo, page) {\n    const viewItem = {\n      id: generateId('viewItem'),\n      outletId,\n      ionPageElement: page,\n      reactElement,\n      mount: true,\n      ionRoute: false\n    };\n    const matchProps = {\n      exact: reactElement.props.exact,\n      path: reactElement.props.path || reactElement.props.from,\n      component: reactElement.props.component\n    };\n    const match = matchPath(routeInfo.pathname, matchProps);\n\n    if (reactElement.type === IonRoute) {\n      viewItem.ionRoute = true;\n      viewItem.disableIonPageManagement = reactElement.props.disableIonPageManagement;\n    }\n\n    viewItem.routeData = {\n      match,\n      childProps: reactElement.props\n    };\n    return viewItem;\n  }\n\n  getChildrenToRender(outletId, ionRouterOutlet, routeInfo) {\n    const viewItems = this.getViewItemsForOutlet(outletId); // Sync latest routes with viewItems\n\n    React.Children.forEach(ionRouterOutlet.props.children, child => {\n      const viewItem = viewItems.find(v => {\n        return matchComponent$1(child, v.routeData.childProps.path || v.routeData.childProps.from);\n      });\n\n      if (viewItem) {\n        viewItem.reactElement = child;\n      }\n    });\n    const children = viewItems.map(viewItem => {\n      let clonedChild;\n\n      if (viewItem.ionRoute && !viewItem.disableIonPageManagement) {\n        clonedChild = React.createElement(ViewLifeCycleManager, {\n          key: `view-${viewItem.id}`,\n          mount: viewItem.mount,\n          removeView: () => this.remove(viewItem)\n        }, React.cloneElement(viewItem.reactElement, {\n          computedMatch: viewItem.routeData.match\n        }));\n      } else {\n        const match = matchComponent$1(viewItem.reactElement, routeInfo.pathname);\n        clonedChild = React.createElement(ViewLifeCycleManager, {\n          key: `view-${viewItem.id}`,\n          mount: viewItem.mount,\n          removeView: () => this.remove(viewItem)\n        }, React.cloneElement(viewItem.reactElement, {\n          computedMatch: viewItem.routeData.match\n        }));\n\n        if (!match && viewItem.routeData.match) {\n          viewItem.routeData.match = undefined;\n          viewItem.mount = false;\n        }\n      }\n\n      return clonedChild;\n    });\n    return children;\n  }\n\n  findViewItemByRouteInfo(routeInfo, outletId) {\n    const {\n      viewItem,\n      match\n    } = this.findViewItemByPath(routeInfo.pathname, outletId);\n\n    if (viewItem && match) {\n      viewItem.routeData.match = match;\n    }\n\n    return viewItem;\n  }\n\n  findLeavingViewItemByRouteInfo(routeInfo, outletId) {\n    let mustBeIonRoute = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n    const {\n      viewItem\n    } = this.findViewItemByPath(routeInfo.lastPathname, outletId, false, mustBeIonRoute);\n    return viewItem;\n  }\n\n  findViewItemByPathname(pathname, outletId) {\n    const {\n      viewItem\n    } = this.findViewItemByPath(pathname, outletId);\n    return viewItem;\n  }\n\n  findViewItemByPath(pathname, outletId, forceExact, mustBeIonRoute) {\n    let viewItem;\n    let match;\n    let viewStack;\n\n    if (outletId) {\n      viewStack = this.getViewItemsForOutlet(outletId);\n      viewStack.some(matchView);\n\n      if (!viewItem) {\n        viewStack.some(matchDefaultRoute);\n      }\n    } else {\n      const viewItems = this.getAllViewItems();\n      viewItems.some(matchView);\n\n      if (!viewItem) {\n        viewItems.some(matchDefaultRoute);\n      }\n    }\n\n    return {\n      viewItem,\n      match\n    };\n\n    function matchView(v) {\n      if (mustBeIonRoute && !v.ionRoute) {\n        return false;\n      }\n\n      const matchProps = {\n        exact: forceExact ? true : v.routeData.childProps.exact,\n        path: v.routeData.childProps.path || v.routeData.childProps.from,\n        component: v.routeData.childProps.component\n      };\n      const myMatch = matchPath(pathname, matchProps);\n\n      if (myMatch) {\n        viewItem = v;\n        match = myMatch;\n        return true;\n      }\n\n      return false;\n    }\n\n    function matchDefaultRoute(v) {\n      // try to find a route that doesn't have a path or from prop, that will be our default route\n      if (!v.routeData.childProps.path && !v.routeData.childProps.from) {\n        match = {\n          path: pathname,\n          url: pathname,\n          isExact: true,\n          params: {}\n        };\n        viewItem = v;\n        return true;\n      }\n\n      return false;\n    }\n  }\n\n}\n\nfunction matchComponent$1(node, pathname, forceExact) {\n  const matchProps = {\n    exact: forceExact ? true : node.props.exact,\n    path: node.props.path || node.props.from,\n    component: node.props.component\n  };\n  const match = matchPath(pathname, matchProps);\n  return match;\n}\n\nfunction clonePageElement(leavingViewHtml) {\n  let html;\n\n  if (typeof leavingViewHtml === 'string') {\n    html = leavingViewHtml;\n  } else {\n    html = leavingViewHtml.outerHTML;\n  }\n\n  if (document) {\n    const newEl = document.createElement('div');\n    newEl.innerHTML = html;\n    newEl.style.zIndex = ''; // Remove an existing back button so the new element doesn't get two of them\n\n    const ionBackButton = newEl.getElementsByTagName('ion-back-button');\n\n    if (ionBackButton[0]) {\n      ionBackButton[0].remove();\n    }\n\n    return newEl.firstChild;\n  }\n\n  return undefined;\n}\n\nconst isViewVisible = el => !el.classList.contains('ion-page-invisible') && !el.classList.contains('ion-page-hidden');\n\nclass StackManager extends React.PureComponent {\n  constructor(props) {\n    super(props);\n    this.stackContextValue = {\n      registerIonPage: this.registerIonPage.bind(this),\n      isInOutlet: () => true\n    };\n    this.pendingPageTransition = false;\n    this.registerIonPage = this.registerIonPage.bind(this);\n    this.transitionPage = this.transitionPage.bind(this);\n    this.handlePageTransition = this.handlePageTransition.bind(this);\n    this.id = generateId('routerOutlet');\n  }\n\n  componentDidMount() {\n    if (this.routerOutletElement) {\n      this.setupRouterOutlet(this.routerOutletElement); // console.log(`SM Mount - ${this.routerOutletElement.id} (${this.id})`);\n\n      this.handlePageTransition(this.props.routeInfo);\n    }\n  }\n\n  componentDidUpdate(prevProps) {\n    if (this.props.routeInfo.pathname !== prevProps.routeInfo.pathname || this.pendingPageTransition) {\n      this.handlePageTransition(this.props.routeInfo);\n      this.pendingPageTransition = false;\n    }\n  }\n\n  componentWillUnmount() {\n    // console.log(`SM UNMount - ${(this.routerOutletElement?.id as any).id} (${this.id})`);\n    this.context.clearOutlet(this.id);\n  }\n\n  async handlePageTransition(routeInfo) {\n    var _a, _b;\n\n    if (!this.routerOutletElement || !this.routerOutletElement.commit) {\n      /**\n       * The route outlet has not mounted yet. We need to wait for it to render\n       * before we can transition the page.\n       *\n       * Set a flag to indicate that we should transition the page after\n       * the component has updated.\n       */\n      this.pendingPageTransition = true;\n    } else {\n      let enteringViewItem = this.context.findViewItemByRouteInfo(routeInfo, this.id);\n      let leavingViewItem = this.context.findLeavingViewItemByRouteInfo(routeInfo, this.id);\n\n      if (!leavingViewItem && routeInfo.prevRouteLastPathname) {\n        leavingViewItem = this.context.findViewItemByPathname(routeInfo.prevRouteLastPathname, this.id);\n      } // Check if leavingViewItem should be unmounted\n\n\n      if (leavingViewItem) {\n        if (routeInfo.routeAction === 'replace') {\n          leavingViewItem.mount = false;\n        } else if (!(routeInfo.routeAction === 'push' && routeInfo.routeDirection === 'forward')) {\n          if (routeInfo.routeDirection !== 'none' && enteringViewItem !== leavingViewItem) {\n            leavingViewItem.mount = false;\n          }\n        } else if ((_a = routeInfo.routeOptions) === null || _a === void 0 ? void 0 : _a.unmount) {\n          leavingViewItem.mount = false;\n        }\n      }\n\n      const enteringRoute = matchRoute((_b = this.ionRouterOutlet) === null || _b === void 0 ? void 0 : _b.props.children, routeInfo);\n\n      if (enteringViewItem) {\n        enteringViewItem.reactElement = enteringRoute;\n      } else if (enteringRoute) {\n        enteringViewItem = this.context.createViewItem(this.id, enteringRoute, routeInfo);\n        this.context.addViewItem(enteringViewItem);\n      }\n\n      if (enteringViewItem && enteringViewItem.ionPageElement) {\n        /**\n         * If the entering view item is the same as the leaving view item,\n         * then we don't need to transition.\n         */\n        if (enteringViewItem === leavingViewItem) {\n          /**\n           * If the entering view item is the same as the leaving view item,\n           * we are either transitioning using parameterized routes to the same view\n           * or a parent router outlet is re-rendering as a result of React props changing.\n           *\n           * If the route data does not match the current path, the parent router outlet\n           * is attempting to transition and we cancel the operation.\n           */\n          if (enteringViewItem.routeData.match.url !== routeInfo.pathname) {\n            return;\n          }\n        }\n        /**\n         * If there isn't a leaving view item, but the route info indicates\n         * that the user has routed from a previous path, then we need\n         * to find the leaving view item to transition between.\n         */\n\n\n        if (!leavingViewItem && this.props.routeInfo.prevRouteLastPathname) {\n          leavingViewItem = this.context.findViewItemByPathname(this.props.routeInfo.prevRouteLastPathname, this.id);\n        }\n        /**\n         * If the entering view is already visible and the leaving view is not, the transition does not need to occur.\n         */\n\n\n        if (isViewVisible(enteringViewItem.ionPageElement) && leavingViewItem !== undefined && !isViewVisible(leavingViewItem.ionPageElement)) {\n          return;\n        }\n        /**\n         * The view should only be transitioned in the following cases:\n         * 1. Performing a replace or pop action, such as a swipe to go back gesture\n         * to animation the leaving view off the screen.\n         *\n         * 2. Navigating between top-level router outlets, such as /page-1 to /page-2;\n         * or navigating within a nested outlet, such as /tabs/tab-1 to /tabs/tab-2.\n         *\n         * 3. The entering view is an ion-router-outlet containing a page\n         * matching the current route and that hasn't already transitioned in.\n         *\n         * This should only happen when navigating directly to a nested router outlet\n         * route or on an initial page load (i.e. refreshing). In cases when loading\n         * /tabs/tab-1, we need to transition the /tabs page element into the view.\n         */\n\n\n        this.transitionPage(routeInfo, enteringViewItem, leavingViewItem);\n      } else if (leavingViewItem && !enteringRoute && !enteringViewItem) {\n        // If we have a leavingView but no entering view/route, we are probably leaving to\n        // another outlet, so hide this leavingView. We do it in a timeout to give time for a\n        // transition to finish.\n        // setTimeout(() => {\n        if (leavingViewItem.ionPageElement) {\n          leavingViewItem.ionPageElement.classList.add('ion-page-hidden');\n          leavingViewItem.ionPageElement.setAttribute('aria-hidden', 'true');\n        } // }, 250);\n\n      }\n\n      this.forceUpdate();\n    }\n  }\n\n  registerIonPage(page, routeInfo) {\n    const foundView = this.context.findViewItemByRouteInfo(routeInfo, this.id);\n\n    if (foundView) {\n      foundView.ionPageElement = page;\n      foundView.ionRoute = true;\n    }\n\n    this.handlePageTransition(routeInfo);\n  }\n\n  async setupRouterOutlet(routerOutlet) {\n    const canStart = () => {\n      const config = getConfig();\n      const swipeEnabled = config && config.get('swipeBackEnabled', routerOutlet.mode === 'ios');\n\n      if (swipeEnabled) {\n        return this.context.canGoBack();\n      } else {\n        return false;\n      }\n    };\n\n    const onStart = () => {\n      this.context.goBack();\n    };\n\n    routerOutlet.swipeHandler = {\n      canStart,\n      onStart,\n      onEnd: _shouldContinue => true\n    };\n  }\n\n  async transitionPage(routeInfo, enteringViewItem, leavingViewItem) {\n    const routerOutlet = this.routerOutletElement;\n    const direction = routeInfo.routeDirection === 'none' || routeInfo.routeDirection === 'root' ? undefined : routeInfo.routeDirection;\n\n    if (enteringViewItem && enteringViewItem.ionPageElement && this.routerOutletElement) {\n      if (leavingViewItem && leavingViewItem.ionPageElement && enteringViewItem === leavingViewItem) {\n        // If a page is transitioning to another version of itself\n        // we clone it so we can have an animation to show\n        const match = matchComponent(leavingViewItem.reactElement, routeInfo.pathname, true);\n\n        if (match) {\n          const newLeavingElement = clonePageElement(leavingViewItem.ionPageElement.outerHTML);\n\n          if (newLeavingElement) {\n            this.routerOutletElement.appendChild(newLeavingElement);\n            await runCommit(enteringViewItem.ionPageElement, newLeavingElement);\n            this.routerOutletElement.removeChild(newLeavingElement);\n          }\n        } else {\n          await runCommit(enteringViewItem.ionPageElement, undefined);\n        }\n      } else {\n        await runCommit(enteringViewItem.ionPageElement, leavingViewItem === null || leavingViewItem === void 0 ? void 0 : leavingViewItem.ionPageElement);\n\n        if (leavingViewItem && leavingViewItem.ionPageElement) {\n          leavingViewItem.ionPageElement.classList.add('ion-page-hidden');\n          leavingViewItem.ionPageElement.setAttribute('aria-hidden', 'true');\n        }\n      }\n    }\n\n    async function runCommit(enteringEl, leavingEl) {\n      enteringEl.classList.add('ion-page');\n      enteringEl.classList.add('ion-page-invisible');\n      await routerOutlet.commit(enteringEl, leavingEl, {\n        deepWait: true,\n        duration: direction === undefined ? 0 : undefined,\n        direction: direction,\n        showGoBack: !!routeInfo.pushedByRoute,\n        progressAnimation: false,\n        animationBuilder: routeInfo.routeAnimation\n      });\n    }\n  }\n\n  render() {\n    const {\n      children\n    } = this.props;\n    const ionRouterOutlet = React.Children.only(children);\n    this.ionRouterOutlet = ionRouterOutlet;\n    const components = this.context.getChildrenToRender(this.id, this.ionRouterOutlet, this.props.routeInfo, () => {\n      this.forceUpdate();\n    });\n    return React.createElement(StackContext.Provider, {\n      value: this.stackContextValue\n    }, React.cloneElement(ionRouterOutlet, {\n      ref: node => {\n        if (ionRouterOutlet.props.setRef) {\n          ionRouterOutlet.props.setRef(node);\n        }\n\n        if (ionRouterOutlet.props.forwardedRef) {\n          ionRouterOutlet.props.forwardedRef.current = node;\n        }\n\n        this.routerOutletElement = node;\n        const {\n          ref\n        } = ionRouterOutlet;\n\n        if (typeof ref === 'function') {\n          ref(node);\n        }\n      }\n    }, components));\n  }\n\n  static get contextType() {\n    return RouteManagerContext;\n  }\n\n}\n\nfunction matchRoute(node, routeInfo) {\n  let matchedNode;\n  React.Children.forEach(node, child => {\n    const matchProps = {\n      exact: child.props.exact,\n      path: child.props.path || child.props.from,\n      component: child.props.component\n    };\n    const match = matchPath$1(routeInfo.pathname, matchProps);\n\n    if (match) {\n      matchedNode = child;\n    }\n  });\n\n  if (matchedNode) {\n    return matchedNode;\n  } // If we haven't found a node\n  // try to find one that doesn't have a path or from prop, that will be our not found route\n\n\n  React.Children.forEach(node, child => {\n    if (!(child.props.path || child.props.from)) {\n      matchedNode = child;\n    }\n  });\n  return matchedNode;\n}\n\nfunction matchComponent(node, pathname, forceExact) {\n  const matchProps = {\n    exact: forceExact ? true : node.props.exact,\n    path: node.props.path || node.props.from,\n    component: node.props.component\n  };\n  const match = matchPath$1(pathname, matchProps);\n  return match;\n}\n\nclass IonRouterInner extends React.PureComponent {\n  constructor(props) {\n    super(props);\n    this.exitViewFromOtherOutletHandlers = [];\n    this.locationHistory = new LocationHistory();\n    this.viewStack = new ReactRouterViewStack();\n    this.routeMangerContextState = {\n      canGoBack: () => this.locationHistory.canGoBack(),\n      clearOutlet: this.viewStack.clear,\n      findViewItemByPathname: this.viewStack.findViewItemByPathname,\n      getChildrenToRender: this.viewStack.getChildrenToRender,\n      goBack: () => this.handleNavigateBack(),\n      createViewItem: this.viewStack.createViewItem,\n      findViewItemByRouteInfo: this.viewStack.findViewItemByRouteInfo,\n      findLeavingViewItemByRouteInfo: this.viewStack.findLeavingViewItemByRouteInfo,\n      addViewItem: this.viewStack.add,\n      unMountViewItem: this.viewStack.remove\n    };\n    const routeInfo = {\n      id: generateId('routeInfo'),\n      pathname: this.props.location.pathname,\n      search: this.props.location.search\n    };\n    this.locationHistory.add(routeInfo);\n    this.handleChangeTab = this.handleChangeTab.bind(this);\n    this.handleResetTab = this.handleResetTab.bind(this);\n    this.handleNativeBack = this.handleNativeBack.bind(this);\n    this.handleNavigate = this.handleNavigate.bind(this);\n    this.handleNavigateBack = this.handleNavigateBack.bind(this);\n    this.props.registerHistoryListener(this.handleHistoryChange.bind(this));\n    this.handleSetCurrentTab = this.handleSetCurrentTab.bind(this);\n    this.state = {\n      routeInfo\n    };\n  }\n\n  handleChangeTab(tab, path, routeOptions) {\n    if (!path) {\n      return;\n    }\n\n    const routeInfo = this.locationHistory.getCurrentRouteInfoForTab(tab);\n    const [pathname, search] = path.split('?');\n\n    if (routeInfo) {\n      this.incomingRouteParams = Object.assign(Object.assign({}, routeInfo), {\n        routeAction: 'push',\n        routeDirection: 'none'\n      });\n\n      if (routeInfo.pathname === pathname) {\n        this.incomingRouteParams.routeOptions = routeOptions;\n        this.props.history.push(routeInfo.pathname + (routeInfo.search || ''));\n      } else {\n        this.incomingRouteParams.pathname = pathname;\n        this.incomingRouteParams.search = search ? '?' + search : undefined;\n        this.incomingRouteParams.routeOptions = routeOptions;\n        this.props.history.push(pathname + (search ? '?' + search : ''));\n      }\n    } else {\n      this.handleNavigate(pathname, 'push', 'none', undefined, routeOptions, tab);\n    }\n  }\n\n  handleHistoryChange(location, action) {\n    var _a, _b, _c;\n\n    let leavingLocationInfo;\n\n    if (this.incomingRouteParams) {\n      if (this.incomingRouteParams.routeAction === 'replace') {\n        leavingLocationInfo = this.locationHistory.previous();\n      } else {\n        leavingLocationInfo = this.locationHistory.current();\n      }\n    } else {\n      leavingLocationInfo = this.locationHistory.current();\n    }\n\n    const leavingUrl = leavingLocationInfo.pathname + leavingLocationInfo.search;\n\n    if (leavingUrl !== location.pathname) {\n      if (!this.incomingRouteParams) {\n        if (action === 'REPLACE') {\n          this.incomingRouteParams = {\n            routeAction: 'replace',\n            routeDirection: 'none',\n            tab: this.currentTab\n          };\n        }\n\n        if (action === 'POP') {\n          const currentRoute = this.locationHistory.current();\n\n          if (currentRoute && currentRoute.pushedByRoute) {\n            const prevInfo = this.locationHistory.findLastLocation(currentRoute);\n            this.incomingRouteParams = Object.assign(Object.assign({}, prevInfo), {\n              routeAction: 'pop',\n              routeDirection: 'back'\n            });\n          } else {\n            this.incomingRouteParams = {\n              routeAction: 'pop',\n              routeDirection: 'none',\n              tab: this.currentTab\n            };\n          }\n        }\n\n        if (!this.incomingRouteParams) {\n          this.incomingRouteParams = {\n            routeAction: 'push',\n            routeDirection: ((_a = location.state) === null || _a === void 0 ? void 0 : _a.direction) || 'forward',\n            routeOptions: (_b = location.state) === null || _b === void 0 ? void 0 : _b.routerOptions,\n            tab: this.currentTab\n          };\n        }\n      }\n\n      let routeInfo;\n\n      if ((_c = this.incomingRouteParams) === null || _c === void 0 ? void 0 : _c.id) {\n        routeInfo = Object.assign(Object.assign({}, this.incomingRouteParams), {\n          lastPathname: leavingLocationInfo.pathname\n        });\n        this.locationHistory.add(routeInfo);\n      } else {\n        const isPushed = this.incomingRouteParams.routeAction === 'push' && this.incomingRouteParams.routeDirection === 'forward';\n        routeInfo = Object.assign(Object.assign({\n          id: generateId('routeInfo')\n        }, this.incomingRouteParams), {\n          lastPathname: leavingLocationInfo.pathname,\n          pathname: location.pathname,\n          search: location.search,\n          params: this.props.match.params,\n          prevRouteLastPathname: leavingLocationInfo.lastPathname\n        });\n\n        if (isPushed) {\n          routeInfo.tab = leavingLocationInfo.tab;\n          routeInfo.pushedByRoute = leavingLocationInfo.pathname;\n        } else if (routeInfo.routeAction === 'pop') {\n          const r = this.locationHistory.findLastLocation(routeInfo);\n          routeInfo.pushedByRoute = r === null || r === void 0 ? void 0 : r.pushedByRoute;\n        } else if (routeInfo.routeAction === 'push' && routeInfo.tab !== leavingLocationInfo.tab) {\n          // If we are switching tabs grab the last route info for the tab and use its pushedByRoute\n          const lastRoute = this.locationHistory.getCurrentRouteInfoForTab(routeInfo.tab);\n          routeInfo.pushedByRoute = lastRoute === null || lastRoute === void 0 ? void 0 : lastRoute.pushedByRoute;\n        } else if (routeInfo.routeAction === 'replace') {\n          // Make sure to set the lastPathname, etc.. to the current route so the page transitions out\n          const currentRouteInfo = this.locationHistory.current();\n          /**\n           * If going from /home to /child, then replacing from\n           * /child to /home, we don't want the route info to\n           * say that /home was pushed by /home which is not correct.\n           */\n\n          const currentPushedBy = currentRouteInfo === null || currentRouteInfo === void 0 ? void 0 : currentRouteInfo.pushedByRoute;\n          const pushedByRoute = currentPushedBy !== undefined && currentPushedBy !== routeInfo.pathname ? currentPushedBy : routeInfo.pushedByRoute;\n          routeInfo.lastPathname = (currentRouteInfo === null || currentRouteInfo === void 0 ? void 0 : currentRouteInfo.pathname) || routeInfo.lastPathname;\n          routeInfo.prevRouteLastPathname = currentRouteInfo === null || currentRouteInfo === void 0 ? void 0 : currentRouteInfo.lastPathname;\n          routeInfo.pushedByRoute = pushedByRoute;\n          routeInfo.routeDirection = (currentRouteInfo === null || currentRouteInfo === void 0 ? void 0 : currentRouteInfo.routeDirection) || routeInfo.routeDirection;\n          routeInfo.routeAnimation = (currentRouteInfo === null || currentRouteInfo === void 0 ? void 0 : currentRouteInfo.routeAnimation) || routeInfo.routeAnimation;\n        }\n\n        this.locationHistory.add(routeInfo);\n      }\n\n      this.setState({\n        routeInfo\n      });\n    }\n\n    this.incomingRouteParams = undefined;\n  }\n  /**\n   * history@4.x uses goBack(), history@5.x uses back()\n   * TODO: If support for React Router <=5 is dropped\n   * this logic is no longer needed. We can just\n   * assume back() is available.\n   */\n\n\n  handleNativeBack() {\n    const history = this.props.history;\n    const goBack = history.goBack || history.back;\n    goBack();\n  }\n\n  handleNavigate(path, routeAction, routeDirection, routeAnimation, routeOptions, tab) {\n    this.incomingRouteParams = Object.assign(this.incomingRouteParams || {}, {\n      routeAction,\n      routeDirection,\n      routeOptions,\n      routeAnimation,\n      tab\n    });\n\n    if (routeAction === 'push') {\n      this.props.history.push(path);\n    } else {\n      this.props.history.replace(path);\n    }\n  }\n\n  handleNavigateBack() {\n    let defaultHref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '/';\n    let routeAnimation = arguments.length > 1 ? arguments[1] : undefined;\n    const config = getConfig();\n    defaultHref = defaultHref ? defaultHref : config && config.get('backButtonDefaultHref');\n    const routeInfo = this.locationHistory.current();\n\n    if (routeInfo && routeInfo.pushedByRoute) {\n      const prevInfo = this.locationHistory.findLastLocation(routeInfo);\n\n      if (prevInfo) {\n        this.incomingRouteParams = Object.assign(Object.assign({}, prevInfo), {\n          routeAction: 'pop',\n          routeDirection: 'back',\n          routeAnimation: routeAnimation || routeInfo.routeAnimation\n        });\n\n        if (routeInfo.lastPathname === routeInfo.pushedByRoute ||\n        /**\n         * We need to exclude tab switches/tab\n         * context changes here because tabbed\n         * navigation is not linear, but router.back()\n         * will go back in a linear fashion.\n         */\n        prevInfo.pathname === routeInfo.pushedByRoute && routeInfo.tab === '' && prevInfo.tab === '') {\n          /**\n           * history@4.x uses goBack(), history@5.x uses back()\n           * TODO: If support for React Router <=5 is dropped\n           * this logic is no longer needed. We can just\n           * assume back() is available.\n           */\n          const history = this.props.history;\n          const goBack = history.goBack || history.back;\n          goBack();\n        } else {\n          this.handleNavigate(prevInfo.pathname + (prevInfo.search || ''), 'pop', 'back');\n        }\n      } else {\n        this.handleNavigate(defaultHref, 'pop', 'back');\n      }\n    } else {\n      this.handleNavigate(defaultHref, 'pop', 'back');\n    }\n  }\n\n  handleResetTab(tab, originalHref, originalRouteOptions) {\n    const routeInfo = this.locationHistory.getFirstRouteInfoForTab(tab);\n\n    if (routeInfo) {\n      const newRouteInfo = Object.assign({}, routeInfo);\n      newRouteInfo.pathname = originalHref;\n      newRouteInfo.routeOptions = originalRouteOptions;\n      this.incomingRouteParams = Object.assign(Object.assign({}, newRouteInfo), {\n        routeAction: 'pop',\n        routeDirection: 'back'\n      });\n      this.props.history.push(newRouteInfo.pathname + (newRouteInfo.search || ''));\n    }\n  }\n\n  handleSetCurrentTab(tab) {\n    this.currentTab = tab;\n    const ri = Object.assign({}, this.locationHistory.current());\n\n    if (ri.tab !== tab) {\n      ri.tab = tab;\n      this.locationHistory.update(ri);\n    }\n  }\n\n  render() {\n    return React.createElement(RouteManagerContext.Provider, {\n      value: this.routeMangerContextState\n    }, React.createElement(NavManager, {\n      ionRoute: IonRouteInner,\n      ionRedirect: {},\n      stackManager: StackManager,\n      routeInfo: this.state.routeInfo,\n      onNativeBack: this.handleNativeBack,\n      onNavigateBack: this.handleNavigateBack,\n      onNavigate: this.handleNavigate,\n      onSetCurrentTab: this.handleSetCurrentTab,\n      onChangeTab: this.handleChangeTab,\n      onResetTab: this.handleResetTab,\n      locationHistory: this.locationHistory\n    }, this.props.children));\n  }\n\n}\n\nconst IonRouter = withRouter(IonRouterInner);\nIonRouter.displayName = 'IonRouter';\n\nclass IonReactRouter extends React.Component {\n  constructor(props) {\n    super(props);\n\n    const {\n      history\n    } = props,\n          rest = __rest(props, [\"history\"]);\n\n    this.history = history || createBrowserHistory(rest);\n    this.history.listen(this.handleHistoryChange.bind(this));\n    this.registerHistoryListener = this.registerHistoryListener.bind(this);\n  }\n  /**\n   * history@4.x passes separate location and action\n   * params. history@5.x passes location and action\n   * together as a single object.\n   * TODO: If support for React Router <=5 is dropped\n   * this logic is no longer needed. We can just assume\n   * a single object with both location and action.\n   */\n\n\n  handleHistoryChange(location, action) {\n    const locationValue = location.location || location;\n    const actionValue = location.action || action;\n\n    if (this.historyListenHandler) {\n      this.historyListenHandler(locationValue, actionValue);\n    }\n  }\n\n  registerHistoryListener(cb) {\n    this.historyListenHandler = cb;\n  }\n\n  render() {\n    const _a = this.props,\n          {\n      children\n    } = _a,\n          props = __rest(_a, [\"children\"]);\n\n    return React.createElement(Router, Object.assign({\n      history: this.history\n    }, props), React.createElement(IonRouter, {\n      registerHistoryListener: this.registerHistoryListener\n    }, children));\n  }\n\n}\n\nclass IonReactMemoryRouter extends React.Component {\n  constructor(props) {\n    super(props);\n    this.history = props.history;\n    this.history.listen(this.handleHistoryChange.bind(this));\n    this.registerHistoryListener = this.registerHistoryListener.bind(this);\n  }\n  /**\n   * history@4.x passes separate location and action\n   * params. history@5.x passes location and action\n   * together as a single object.\n   * TODO: If support for React Router <=5 is dropped\n   * this logic is no longer needed. We can just assume\n   * a single object with both location and action.\n   */\n\n\n  handleHistoryChange(location, action) {\n    const locationValue = location.location || location;\n    const actionValue = location.action || action;\n\n    if (this.historyListenHandler) {\n      this.historyListenHandler(locationValue, actionValue);\n    }\n  }\n\n  registerHistoryListener(cb) {\n    this.historyListenHandler = cb;\n  }\n\n  render() {\n    const _a = this.props,\n          {\n      children\n    } = _a,\n          props = __rest(_a, [\"children\"]);\n\n    return React.createElement(Router$1, Object.assign({}, props), React.createElement(IonRouter, {\n      registerHistoryListener: this.registerHistoryListener\n    }, children));\n  }\n\n}\n\nclass IonReactHashRouter extends React.Component {\n  constructor(props) {\n    super(props);\n\n    const {\n      history\n    } = props,\n          rest = __rest(props, [\"history\"]);\n\n    this.history = history || createHashHistory(rest);\n    this.history.listen(this.handleHistoryChange.bind(this));\n    this.registerHistoryListener = this.registerHistoryListener.bind(this);\n  }\n  /**\n   * history@4.x passes separate location and action\n   * params. history@5.x passes location and action\n   * together as a single object.\n   * TODO: If support for React Router <=5 is dropped\n   * this logic is no longer needed. We can just assume\n   * a single object with both location and action.\n   */\n\n\n  handleHistoryChange(location, action) {\n    const locationValue = location.location || location;\n    const actionValue = location.action || action;\n\n    if (this.historyListenHandler) {\n      this.historyListenHandler(locationValue, actionValue);\n    }\n  }\n\n  registerHistoryListener(cb) {\n    this.historyListenHandler = cb;\n  }\n\n  render() {\n    const _a = this.props,\n          {\n      children\n    } = _a,\n          props = __rest(_a, [\"children\"]);\n\n    return React.createElement(Router, Object.assign({\n      history: this.history\n    }, props), React.createElement(IonRouter, {\n      registerHistoryListener: this.registerHistoryListener\n    }, children));\n  }\n\n}\n\nexport { IonReactHashRouter, IonReactMemoryRouter, IonReactRouter };","map":{"version":3,"mappings":"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","names":["IonRouteInner","React","PureComponent","render","Route","path","props","exact","computedMatch","ReactRouterViewStack","ViewStacks","constructor","createViewItem","bind","findViewItemByRouteInfo","findLeavingViewItemByRouteInfo","getChildrenToRender","findViewItemByPathname","outletId","reactElement","routeInfo","page","viewItem","id","generateId","ionPageElement","mount","ionRoute","matchProps","from","component","match","matchPath","pathname","type","IonRoute","disableIonPageManagement","routeData","childProps","ionRouterOutlet","viewItems","getViewItemsForOutlet","Children","forEach","children","child","find","v","matchComponent","map","clonedChild","ViewLifeCycleManager","key","removeView","remove","cloneElement","undefined","findViewItemByPath","mustBeIonRoute","lastPathname","forceExact","viewStack","some","matchView","matchDefaultRoute","getAllViewItems","myMatch","url","isExact","params","node","clonePageElement","leavingViewHtml","html","outerHTML","document","newEl","createElement","innerHTML","style","zIndex","ionBackButton","getElementsByTagName","firstChild","isViewVisible","el","classList","contains","StackManager","registerIonPage","isInOutlet","transitionPage","handlePageTransition","componentDidMount","routerOutletElement","setupRouterOutlet","componentDidUpdate","prevProps","pendingPageTransition","componentWillUnmount","context","clearOutlet","commit","enteringViewItem","leavingViewItem","prevRouteLastPathname","routeAction","routeDirection","routeOptions","_a","unmount","enteringRoute","matchRoute","_b","addViewItem","add","setAttribute","forceUpdate","foundView","routerOutlet","canStart","config","getConfig","swipeEnabled","get","mode","canGoBack","onStart","goBack","swipeHandler","onEnd","_shouldContinue","direction","newLeavingElement","appendChild","runCommit","removeChild","enteringEl","leavingEl","deepWait","duration","showGoBack","pushedByRoute","progressAnimation","animationBuilder","routeAnimation","only","components","StackContext","Provider","value","stackContextValue","ref","setRef","forwardedRef","current","contextType","RouteManagerContext","matchedNode","IonRouterInner","LocationHistory","locationHistory","clear","handleNavigateBack","unMountViewItem","location","search","handleChangeTab","handleResetTab","handleNativeBack","handleNavigate","registerHistoryListener","handleHistoryChange","handleSetCurrentTab","state","tab","getCurrentRouteInfoForTab","split","incomingRouteParams","Object","history","push","action","leavingLocationInfo","previous","leavingUrl","currentTab","currentRoute","prevInfo","findLastLocation","routerOptions","_c","isPushed","r","lastRoute","currentRouteInfo","currentPushedBy","setState","back","assign","replace","defaultHref","originalHref","originalRouteOptions","getFirstRouteInfoForTab","newRouteInfo","ri","update","routeMangerContextState","NavManager","ionRedirect","stackManager","onNativeBack","onNavigateBack","onNavigate","onSetCurrentTab","onChangeTab","onResetTab","IonRouter","withRouter","displayName","IonReactRouter","Component","rest","createHistory","listen","locationValue","actionValue","historyListenHandler","cb","Router","IonReactMemoryRouter","IonReactHashRouter"],"sources":["/Users/brittanymorris/Desktop/ipo_app/node_modules/@ionic/react-router/src/ReactRouter/IonRouteInner.tsx","/Users/brittanymorris/Desktop/ipo_app/node_modules/@ionic/react-router/src/ReactRouter/ReactRouterViewStack.tsx","/Users/brittanymorris/Desktop/ipo_app/node_modules/@ionic/react-router/src/ReactRouter/clonePageElement.ts","/Users/brittanymorris/Desktop/ipo_app/node_modules/@ionic/react-router/src/ReactRouter/StackManager.tsx","/Users/brittanymorris/Desktop/ipo_app/node_modules/@ionic/react-router/src/ReactRouter/IonRouter.tsx","/Users/brittanymorris/Desktop/ipo_app/node_modules/@ionic/react-router/src/ReactRouter/IonReactRouter.tsx","/Users/brittanymorris/Desktop/ipo_app/node_modules/@ionic/react-router/src/ReactRouter/IonReactMemoryRouter.tsx","/Users/brittanymorris/Desktop/ipo_app/node_modules/@ionic/react-router/src/ReactRouter/IonReactHashRouter.tsx"],"sourcesContent":["import { IonRouteProps } from '@ionic/react';\nimport React from 'react';\nimport { Route } from 'react-router';\n\nexport class IonRouteInner extends React.PureComponent<IonRouteProps> {\n  render() {\n    return (\n      <Route\n        path={this.props.path}\n        exact={this.props.exact}\n        render={this.props.render}\n        /**\n         * `computedMatch` is a private API in react-router v5 that\n         * has been removed in v6.\n         *\n         * This needs to be removed when we support v6.\n         *\n         * TODO: FW-647\n         */\n        computedMatch={(this.props as any).computedMatch}\n      />\n    );\n  }\n}\n","import {\n  IonRoute,\n  RouteInfo,\n  ViewItem,\n  ViewLifeCycleManager,\n  ViewStacks,\n  generateId,\n} from '@ionic/react';\nimport React from 'react';\nimport { matchPath } from 'react-router';\n\nexport class ReactRouterViewStack extends ViewStacks {\n  constructor() {\n    super();\n    this.createViewItem = this.createViewItem.bind(this);\n    this.findViewItemByRouteInfo = this.findViewItemByRouteInfo.bind(this);\n    this.findLeavingViewItemByRouteInfo = this.findLeavingViewItemByRouteInfo.bind(this);\n    this.getChildrenToRender = this.getChildrenToRender.bind(this);\n    this.findViewItemByPathname = this.findViewItemByPathname.bind(this);\n  }\n\n  createViewItem(\n    outletId: string,\n    reactElement: React.ReactElement,\n    routeInfo: RouteInfo,\n    page?: HTMLElement\n  ) {\n    const viewItem: ViewItem = {\n      id: generateId('viewItem'),\n      outletId,\n      ionPageElement: page,\n      reactElement,\n      mount: true,\n      ionRoute: false,\n    };\n\n    const matchProps = {\n      exact: reactElement.props.exact,\n      path: reactElement.props.path || reactElement.props.from,\n      component: reactElement.props.component,\n    };\n\n    const match = matchPath(routeInfo.pathname, matchProps);\n\n    if (reactElement.type === IonRoute) {\n      viewItem.ionRoute = true;\n      viewItem.disableIonPageManagement = reactElement.props.disableIonPageManagement;\n    }\n\n    viewItem.routeData = {\n      match,\n      childProps: reactElement.props,\n    };\n\n    return viewItem;\n  }\n\n  getChildrenToRender(outletId: string, ionRouterOutlet: React.ReactElement, routeInfo: RouteInfo) {\n    const viewItems = this.getViewItemsForOutlet(outletId);\n\n    // Sync latest routes with viewItems\n    React.Children.forEach(ionRouterOutlet.props.children, (child: React.ReactElement) => {\n      const viewItem = viewItems.find((v) => {\n        return matchComponent(child, v.routeData.childProps.path || v.routeData.childProps.from);\n      });\n      if (viewItem) {\n        viewItem.reactElement = child;\n      }\n    });\n\n    const children = viewItems.map((viewItem) => {\n      let clonedChild;\n      if (viewItem.ionRoute && !viewItem.disableIonPageManagement) {\n        clonedChild = (\n          <ViewLifeCycleManager\n            key={`view-${viewItem.id}`}\n            mount={viewItem.mount}\n            removeView={() => this.remove(viewItem)}\n          >\n            {React.cloneElement(viewItem.reactElement, {\n              computedMatch: viewItem.routeData.match,\n            })}\n          </ViewLifeCycleManager>\n        );\n      } else {\n        const match = matchComponent(viewItem.reactElement, routeInfo.pathname);\n        clonedChild = (\n          <ViewLifeCycleManager\n            key={`view-${viewItem.id}`}\n            mount={viewItem.mount}\n            removeView={() => this.remove(viewItem)}\n          >\n            {React.cloneElement(viewItem.reactElement, {\n              computedMatch: viewItem.routeData.match,\n            })}\n          </ViewLifeCycleManager>\n        );\n\n        if (!match && viewItem.routeData.match) {\n          viewItem.routeData.match = undefined;\n          viewItem.mount = false;\n        }\n      }\n\n      return clonedChild;\n    });\n    return children;\n  }\n\n  findViewItemByRouteInfo(routeInfo: RouteInfo, outletId?: string) {\n    const { viewItem, match } = this.findViewItemByPath(routeInfo.pathname, outletId);\n    if (viewItem && match) {\n      viewItem.routeData.match = match;\n    }\n    return viewItem;\n  }\n\n  findLeavingViewItemByRouteInfo(routeInfo: RouteInfo, outletId?: string, mustBeIonRoute = true) {\n    const { viewItem } = this.findViewItemByPath(\n      routeInfo.lastPathname!,\n      outletId,\n      false,\n      mustBeIonRoute\n    );\n    return viewItem;\n  }\n\n  findViewItemByPathname(pathname: string, outletId?: string) {\n    const { viewItem } = this.findViewItemByPath(pathname, outletId);\n    return viewItem;\n  }\n\n  private findViewItemByPath(\n    pathname: string,\n    outletId?: string,\n    forceExact?: boolean,\n    mustBeIonRoute?: boolean\n  ) {\n    let viewItem: ViewItem | undefined;\n    let match: ReturnType<typeof matchPath> | undefined;\n    let viewStack: ViewItem[];\n\n    if (outletId) {\n      viewStack = this.getViewItemsForOutlet(outletId);\n      viewStack.some(matchView);\n      if (!viewItem) {\n        viewStack.some(matchDefaultRoute);\n      }\n    } else {\n      const viewItems = this.getAllViewItems();\n      viewItems.some(matchView);\n      if (!viewItem) {\n        viewItems.some(matchDefaultRoute);\n      }\n    }\n\n    return { viewItem, match };\n\n    function matchView(v: ViewItem) {\n      if (mustBeIonRoute && !v.ionRoute) {\n        return false;\n      }\n      const matchProps = {\n        exact: forceExact ? true : v.routeData.childProps.exact,\n        path: v.routeData.childProps.path || v.routeData.childProps.from,\n        component: v.routeData.childProps.component,\n      };\n      const myMatch = matchPath(pathname, matchProps);\n      if (myMatch) {\n        viewItem = v;\n        match = myMatch;\n        return true;\n      }\n      return false;\n    }\n\n    function matchDefaultRoute(v: ViewItem) {\n      // try to find a route that doesn't have a path or from prop, that will be our default route\n      if (!v.routeData.childProps.path && !v.routeData.childProps.from) {\n        match = {\n          path: pathname,\n          url: pathname,\n          isExact: true,\n          params: {},\n        };\n        viewItem = v;\n        return true;\n      }\n      return false;\n    }\n  }\n}\n\nfunction matchComponent(node: React.ReactElement, pathname: string, forceExact?: boolean) {\n  const matchProps = {\n    exact: forceExact ? true : node.props.exact,\n    path: node.props.path || node.props.from,\n    component: node.props.component,\n  };\n  const match = matchPath(pathname, matchProps);\n\n  return match;\n}\n","export function clonePageElement(leavingViewHtml: string | HTMLElement) {\n  let html: string;\n  if (typeof leavingViewHtml === 'string') {\n    html = leavingViewHtml;\n  } else {\n    html = leavingViewHtml.outerHTML;\n  }\n  if (document) {\n    const newEl = document.createElement('div');\n    newEl.innerHTML = html;\n    newEl.style.zIndex = '';\n    // Remove an existing back button so the new element doesn't get two of them\n    const ionBackButton = newEl.getElementsByTagName('ion-back-button');\n    if (ionBackButton[0]) {\n      ionBackButton[0].remove();\n    }\n    return newEl.firstChild as HTMLElement;\n  }\n  return undefined;\n}\n","import {\n  RouteInfo,\n  RouteManagerContext,\n  StackContext,\n  StackContextState,\n  ViewItem,\n  generateId,\n  getConfig,\n} from '@ionic/react';\nimport React from 'react';\nimport { matchPath } from 'react-router-dom';\n\nimport { clonePageElement } from './clonePageElement';\n\ninterface StackManagerProps {\n  routeInfo: RouteInfo;\n}\n\ninterface StackManagerState {}\n\nconst isViewVisible = (el: HTMLElement) => !el.classList.contains('ion-page-invisible') && !el.classList.contains('ion-page-hidden');\n\nexport class StackManager extends React.PureComponent<StackManagerProps, StackManagerState> {\n  id: string;\n  context!: React.ContextType<typeof RouteManagerContext>;\n  ionRouterOutlet?: React.ReactElement;\n  routerOutletElement: HTMLIonRouterOutletElement | undefined;\n\n  stackContextValue: StackContextState = {\n    registerIonPage: this.registerIonPage.bind(this),\n    isInOutlet: () => true,\n  };\n\n  private pendingPageTransition = false;\n\n  constructor(props: StackManagerProps) {\n    super(props);\n    this.registerIonPage = this.registerIonPage.bind(this);\n    this.transitionPage = this.transitionPage.bind(this);\n    this.handlePageTransition = this.handlePageTransition.bind(this);\n    this.id = generateId('routerOutlet');\n  }\n\n  componentDidMount() {\n    if (this.routerOutletElement) {\n      this.setupRouterOutlet(this.routerOutletElement);\n      // console.log(`SM Mount - ${this.routerOutletElement.id} (${this.id})`);\n      this.handlePageTransition(this.props.routeInfo);\n    }\n  }\n\n  componentDidUpdate(prevProps: StackManagerProps) {\n    if (this.props.routeInfo.pathname !== prevProps.routeInfo.pathname || this.pendingPageTransition) {\n      this.handlePageTransition(this.props.routeInfo);\n      this.pendingPageTransition = false;\n    }\n  }\n\n  componentWillUnmount() {\n    // console.log(`SM UNMount - ${(this.routerOutletElement?.id as any).id} (${this.id})`);\n    this.context.clearOutlet(this.id);\n  }\n\n  async handlePageTransition(routeInfo: RouteInfo) {\n    if (!this.routerOutletElement || !this.routerOutletElement.commit) {\n      /**\n       * The route outlet has not mounted yet. We need to wait for it to render\n       * before we can transition the page.\n       *\n       * Set a flag to indicate that we should transition the page after\n       * the component has updated.\n       */\n      this.pendingPageTransition = true;\n    } else {\n      let enteringViewItem = this.context.findViewItemByRouteInfo(routeInfo, this.id);\n      let leavingViewItem = this.context.findLeavingViewItemByRouteInfo(routeInfo, this.id);\n\n      if (!leavingViewItem && routeInfo.prevRouteLastPathname) {\n        leavingViewItem = this.context.findViewItemByPathname(\n          routeInfo.prevRouteLastPathname,\n          this.id\n        );\n      }\n\n      // Check if leavingViewItem should be unmounted\n      if (leavingViewItem) {\n        if (routeInfo.routeAction === 'replace') {\n          leavingViewItem.mount = false;\n        } else if (!(routeInfo.routeAction === 'push' && routeInfo.routeDirection === 'forward')) {\n          if (routeInfo.routeDirection !== 'none' && enteringViewItem !== leavingViewItem) {\n            leavingViewItem.mount = false;\n          }\n        } else if (routeInfo.routeOptions?.unmount) {\n          leavingViewItem.mount = false;\n        }\n      }\n\n      const enteringRoute = matchRoute(\n        this.ionRouterOutlet?.props.children,\n        routeInfo\n      ) as React.ReactElement;\n\n      if (enteringViewItem) {\n        enteringViewItem.reactElement = enteringRoute;\n      } else if (enteringRoute) {\n        enteringViewItem = this.context.createViewItem(this.id, enteringRoute, routeInfo);\n        this.context.addViewItem(enteringViewItem);\n      }\n\n      if (enteringViewItem && enteringViewItem.ionPageElement) {\n        /**\n         * If the entering view item is the same as the leaving view item,\n         * then we don't need to transition.\n         */\n        if (enteringViewItem === leavingViewItem) {\n          /**\n           * If the entering view item is the same as the leaving view item,\n           * we are either transitioning using parameterized routes to the same view\n           * or a parent router outlet is re-rendering as a result of React props changing.\n           *\n           * If the route data does not match the current path, the parent router outlet\n           * is attempting to transition and we cancel the operation.\n           */\n          if (enteringViewItem.routeData.match.url !== routeInfo.pathname) {\n            return;\n          }\n        }\n\n        /**\n         * If there isn't a leaving view item, but the route info indicates\n         * that the user has routed from a previous path, then we need\n         * to find the leaving view item to transition between.\n         */\n        if (!leavingViewItem && this.props.routeInfo.prevRouteLastPathname) {\n          leavingViewItem = this.context.findViewItemByPathname(this.props.routeInfo.prevRouteLastPathname, this.id);\n        }\n\n        /**\n         * If the entering view is already visible and the leaving view is not, the transition does not need to occur.\n         */\n        if (isViewVisible(enteringViewItem.ionPageElement) && leavingViewItem !== undefined && !isViewVisible(leavingViewItem.ionPageElement!)) {\n          return;\n        }\n\n        /**\n         * The view should only be transitioned in the following cases:\n         * 1. Performing a replace or pop action, such as a swipe to go back gesture\n         * to animation the leaving view off the screen.\n         *\n         * 2. Navigating between top-level router outlets, such as /page-1 to /page-2;\n         * or navigating within a nested outlet, such as /tabs/tab-1 to /tabs/tab-2.\n         *\n         * 3. The entering view is an ion-router-outlet containing a page\n         * matching the current route and that hasn't already transitioned in.\n         *\n         * This should only happen when navigating directly to a nested router outlet\n         * route or on an initial page load (i.e. refreshing). In cases when loading\n         * /tabs/tab-1, we need to transition the /tabs page element into the view.\n         */\n        this.transitionPage(routeInfo, enteringViewItem, leavingViewItem);\n      } else if (leavingViewItem && !enteringRoute && !enteringViewItem) {\n        // If we have a leavingView but no entering view/route, we are probably leaving to\n        // another outlet, so hide this leavingView. We do it in a timeout to give time for a\n        // transition to finish.\n        // setTimeout(() => {\n        if (leavingViewItem.ionPageElement) {\n          leavingViewItem.ionPageElement.classList.add('ion-page-hidden');\n          leavingViewItem.ionPageElement.setAttribute('aria-hidden', 'true');\n        }\n        // }, 250);\n      }\n\n      this.forceUpdate();\n    }\n  }\n\n  registerIonPage(page: HTMLElement, routeInfo: RouteInfo) {\n    const foundView = this.context.findViewItemByRouteInfo(routeInfo, this.id);\n    if (foundView) {\n      foundView.ionPageElement = page;\n      foundView.ionRoute = true;\n    }\n    this.handlePageTransition(routeInfo);\n  }\n\n  async setupRouterOutlet(routerOutlet: HTMLIonRouterOutletElement) {\n    const canStart = () => {\n      const config = getConfig();\n      const swipeEnabled = config && config.get('swipeBackEnabled', routerOutlet.mode === 'ios');\n      if (swipeEnabled) {\n        return this.context.canGoBack();\n      } else {\n        return false;\n      }\n    };\n\n    const onStart = () => {\n      this.context.goBack();\n    };\n    routerOutlet.swipeHandler = {\n      canStart,\n      onStart,\n      onEnd: (_shouldContinue) => true,\n    };\n  }\n\n  async transitionPage(\n    routeInfo: RouteInfo,\n    enteringViewItem: ViewItem,\n    leavingViewItem?: ViewItem\n  ) {\n    const routerOutlet = this.routerOutletElement!;\n\n    const direction =\n      routeInfo.routeDirection === 'none' || routeInfo.routeDirection === 'root'\n        ? undefined\n        : routeInfo.routeDirection;\n\n    if (enteringViewItem && enteringViewItem.ionPageElement && this.routerOutletElement) {\n      if (\n        leavingViewItem &&\n        leavingViewItem.ionPageElement &&\n        enteringViewItem === leavingViewItem\n      ) {\n        // If a page is transitioning to another version of itself\n        // we clone it so we can have an animation to show\n\n        const match = matchComponent(leavingViewItem.reactElement, routeInfo.pathname, true);\n        if (match) {\n          const newLeavingElement = clonePageElement(leavingViewItem.ionPageElement.outerHTML);\n          if (newLeavingElement) {\n            this.routerOutletElement.appendChild(newLeavingElement);\n            await runCommit(enteringViewItem.ionPageElement, newLeavingElement);\n            this.routerOutletElement.removeChild(newLeavingElement);\n          }\n        } else {\n          await runCommit(enteringViewItem.ionPageElement, undefined);\n        }\n      } else {\n        await runCommit(enteringViewItem.ionPageElement, leavingViewItem?.ionPageElement);\n        if (leavingViewItem && leavingViewItem.ionPageElement) {\n          leavingViewItem.ionPageElement.classList.add('ion-page-hidden');\n          leavingViewItem.ionPageElement.setAttribute('aria-hidden', 'true');\n        }\n      }\n    }\n\n    async function runCommit(enteringEl: HTMLElement, leavingEl?: HTMLElement) {\n      enteringEl.classList.add('ion-page');\n      enteringEl.classList.add('ion-page-invisible');\n\n      await routerOutlet.commit(enteringEl, leavingEl, {\n        deepWait: true,\n        duration: direction === undefined ? 0 : undefined,\n        direction: direction as any,\n        showGoBack: !!routeInfo.pushedByRoute,\n        progressAnimation: false,\n        animationBuilder: routeInfo.routeAnimation,\n      });\n    }\n  }\n\n  render() {\n    const { children } = this.props;\n    const ionRouterOutlet = React.Children.only(children) as React.ReactElement;\n    this.ionRouterOutlet = ionRouterOutlet;\n\n    const components = this.context.getChildrenToRender(\n      this.id,\n      this.ionRouterOutlet,\n      this.props.routeInfo,\n      () => {\n        this.forceUpdate();\n      }\n    );\n\n    return (\n      <StackContext.Provider value={this.stackContextValue}>\n        {React.cloneElement(\n          ionRouterOutlet as any,\n          {\n            ref: (node: HTMLIonRouterOutletElement) => {\n              if (ionRouterOutlet.props.setRef) {\n                ionRouterOutlet.props.setRef(node);\n              }\n              if (ionRouterOutlet.props.forwardedRef) {\n                ionRouterOutlet.props.forwardedRef.current = node;\n              }\n              this.routerOutletElement = node;\n              const { ref } = ionRouterOutlet as any;\n              if (typeof ref === 'function') {\n                ref(node);\n              }\n            },\n          },\n          components\n        )}\n      </StackContext.Provider>\n    );\n  }\n\n  static get contextType() {\n    return RouteManagerContext;\n  }\n}\n\nexport default StackManager;\n\nfunction matchRoute(node: React.ReactNode, routeInfo: RouteInfo) {\n  let matchedNode: React.ReactNode;\n  React.Children.forEach(node as React.ReactElement, (child: React.ReactElement) => {\n    const matchProps = {\n      exact: child.props.exact,\n      path: child.props.path || child.props.from,\n      component: child.props.component,\n    };\n    const match = matchPath(routeInfo.pathname, matchProps);\n    if (match) {\n      matchedNode = child;\n    }\n  });\n\n  if (matchedNode) {\n    return matchedNode;\n  }\n  // If we haven't found a node\n  // try to find one that doesn't have a path or from prop, that will be our not found route\n  React.Children.forEach(node as React.ReactElement, (child: React.ReactElement) => {\n    if (!(child.props.path || child.props.from)) {\n      matchedNode = child;\n    }\n  });\n\n  return matchedNode;\n}\n\nfunction matchComponent(node: React.ReactElement, pathname: string, forceExact?: boolean) {\n  const matchProps = {\n    exact: forceExact ? true : node.props.exact,\n    path: node.props.path || node.props.from,\n    component: node.props.component,\n  };\n  const match = matchPath(pathname, matchProps);\n\n  return match;\n}\n","import {\n  AnimationBuilder,\n  LocationHistory,\n  NavManager,\n  RouteAction,\n  RouteInfo,\n  RouteManagerContext,\n  RouteManagerContextState,\n  RouterDirection,\n  ViewItem,\n  generateId,\n  getConfig,\n} from '@ionic/react';\nimport { Action as HistoryAction, Location as HistoryLocation } from 'history';\nimport React from 'react';\nimport { RouteComponentProps, withRouter } from 'react-router-dom';\n\nimport { IonRouteInner } from './IonRouteInner';\nimport { ReactRouterViewStack } from './ReactRouterViewStack';\nimport StackManager from './StackManager';\n\nexport interface LocationState {\n  direction?: RouterDirection;\n  routerOptions?: { as?: string; unmount?: boolean };\n}\n\ninterface IonRouteProps extends RouteComponentProps<{}, {}, LocationState> {\n  registerHistoryListener: (\n    cb: (location: HistoryLocation<any>, action: HistoryAction) => void\n  ) => void;\n}\n\ninterface IonRouteState {\n  routeInfo: RouteInfo;\n}\n\nclass IonRouterInner extends React.PureComponent<IonRouteProps, IonRouteState> {\n  currentTab?: string;\n  exitViewFromOtherOutletHandlers: ((pathname: string) => ViewItem | undefined)[] = [];\n  incomingRouteParams?: Partial<RouteInfo>;\n  locationHistory = new LocationHistory();\n  viewStack = new ReactRouterViewStack();\n  routeMangerContextState: RouteManagerContextState = {\n    canGoBack: () => this.locationHistory.canGoBack(),\n    clearOutlet: this.viewStack.clear,\n    findViewItemByPathname: this.viewStack.findViewItemByPathname,\n    getChildrenToRender: this.viewStack.getChildrenToRender,\n    goBack: () => this.handleNavigateBack(),\n    createViewItem: this.viewStack.createViewItem,\n    findViewItemByRouteInfo: this.viewStack.findViewItemByRouteInfo,\n    findLeavingViewItemByRouteInfo: this.viewStack.findLeavingViewItemByRouteInfo,\n    addViewItem: this.viewStack.add,\n    unMountViewItem: this.viewStack.remove,\n  };\n\n  constructor(props: IonRouteProps) {\n    super(props);\n\n    const routeInfo = {\n      id: generateId('routeInfo'),\n      pathname: this.props.location.pathname,\n      search: this.props.location.search,\n    };\n\n    this.locationHistory.add(routeInfo);\n    this.handleChangeTab = this.handleChangeTab.bind(this);\n    this.handleResetTab = this.handleResetTab.bind(this);\n    this.handleNativeBack = this.handleNativeBack.bind(this);\n    this.handleNavigate = this.handleNavigate.bind(this);\n    this.handleNavigateBack = this.handleNavigateBack.bind(this);\n    this.props.registerHistoryListener(this.handleHistoryChange.bind(this));\n    this.handleSetCurrentTab = this.handleSetCurrentTab.bind(this);\n\n    this.state = {\n      routeInfo,\n    };\n  }\n\n  handleChangeTab(tab: string, path?: string, routeOptions?: any) {\n    if (!path) { return; }\n\n    const routeInfo = this.locationHistory.getCurrentRouteInfoForTab(tab);\n    const [pathname, search] = path.split('?');\n    if (routeInfo) {\n      this.incomingRouteParams = { ...routeInfo, routeAction: 'push', routeDirection: 'none' };\n      if (routeInfo.pathname === pathname) {\n        this.incomingRouteParams.routeOptions = routeOptions;\n        this.props.history.push(routeInfo.pathname + (routeInfo.search || ''));\n      } else {\n        this.incomingRouteParams.pathname = pathname;\n        this.incomingRouteParams.search = search ? '?' + search : undefined;\n        this.incomingRouteParams.routeOptions = routeOptions;\n        this.props.history.push(pathname + (search ? '?' + search : ''));\n      }\n    } else {\n      this.handleNavigate(pathname, 'push', 'none', undefined, routeOptions, tab);\n    }\n  }\n\n  handleHistoryChange(location: HistoryLocation<LocationState>, action: HistoryAction) {\n    let leavingLocationInfo: RouteInfo;\n    if (this.incomingRouteParams) {\n      if (this.incomingRouteParams.routeAction === 'replace') {\n        leavingLocationInfo = this.locationHistory.previous();\n      } else {\n        leavingLocationInfo = this.locationHistory.current();\n      }\n    } else {\n      leavingLocationInfo = this.locationHistory.current();\n    }\n\n    const leavingUrl = leavingLocationInfo.pathname + leavingLocationInfo.search;\n    if (leavingUrl !== location.pathname) {\n      if (!this.incomingRouteParams) {\n        if (action === 'REPLACE') {\n          this.incomingRouteParams = {\n            routeAction: 'replace',\n            routeDirection: 'none',\n            tab: this.currentTab, // TODO this isn't legit if replacing to a page that is not in the tabs\n          };\n        }\n        if (action === 'POP') {\n          const currentRoute = this.locationHistory.current();\n          if (currentRoute && currentRoute.pushedByRoute) {\n            const prevInfo = this.locationHistory.findLastLocation(currentRoute);\n            this.incomingRouteParams = { ...prevInfo, routeAction: 'pop', routeDirection: 'back' };\n          } else {\n            this.incomingRouteParams = {\n              routeAction: 'pop',\n              routeDirection: 'none',\n              tab: this.currentTab,\n            };\n          }\n        }\n        if (!this.incomingRouteParams) {\n          this.incomingRouteParams = {\n            routeAction: 'push',\n            routeDirection: location.state?.direction || 'forward',\n            routeOptions: location.state?.routerOptions,\n            tab: this.currentTab,\n          };\n        }\n      }\n\n      let routeInfo: RouteInfo;\n\n      if (this.incomingRouteParams?.id) {\n        routeInfo = {\n          ...(this.incomingRouteParams as RouteInfo),\n          lastPathname: leavingLocationInfo.pathname,\n        };\n        this.locationHistory.add(routeInfo);\n      } else {\n        const isPushed =\n          this.incomingRouteParams.routeAction === 'push' &&\n          this.incomingRouteParams.routeDirection === 'forward';\n        routeInfo = {\n          id: generateId('routeInfo'),\n          ...this.incomingRouteParams,\n          lastPathname: leavingLocationInfo.pathname,\n          pathname: location.pathname,\n          search: location.search,\n          params: this.props.match.params,\n          prevRouteLastPathname: leavingLocationInfo.lastPathname,\n        };\n        if (isPushed) {\n          routeInfo.tab = leavingLocationInfo.tab;\n          routeInfo.pushedByRoute = leavingLocationInfo.pathname;\n        } else if (routeInfo.routeAction === 'pop') {\n          const r = this.locationHistory.findLastLocation(routeInfo);\n          routeInfo.pushedByRoute = r?.pushedByRoute;\n        } else if (routeInfo.routeAction === 'push' && routeInfo.tab !== leavingLocationInfo.tab) {\n          // If we are switching tabs grab the last route info for the tab and use its pushedByRoute\n          const lastRoute = this.locationHistory.getCurrentRouteInfoForTab(routeInfo.tab);\n          routeInfo.pushedByRoute = lastRoute?.pushedByRoute;\n        } else if (routeInfo.routeAction === 'replace') {\n          // Make sure to set the lastPathname, etc.. to the current route so the page transitions out\n          const currentRouteInfo = this.locationHistory.current();\n\n          /**\n           * If going from /home to /child, then replacing from\n           * /child to /home, we don't want the route info to\n           * say that /home was pushed by /home which is not correct.\n           */\n          const currentPushedBy = currentRouteInfo?.pushedByRoute;\n          const pushedByRoute = (currentPushedBy !== undefined && currentPushedBy !== routeInfo.pathname) ? currentPushedBy : routeInfo.pushedByRoute;\n\n          routeInfo.lastPathname = currentRouteInfo?.pathname || routeInfo.lastPathname;\n          routeInfo.prevRouteLastPathname = currentRouteInfo?.lastPathname;\n          routeInfo.pushedByRoute = pushedByRoute;\n          routeInfo.routeDirection = currentRouteInfo?.routeDirection || routeInfo.routeDirection;\n          routeInfo.routeAnimation = currentRouteInfo?.routeAnimation || routeInfo.routeAnimation;\n        }\n\n        this.locationHistory.add(routeInfo);\n      }\n\n      this.setState({\n        routeInfo,\n      });\n    }\n\n    this.incomingRouteParams = undefined;\n  }\n\n  /**\n   * history@4.x uses goBack(), history@5.x uses back()\n   * TODO: If support for React Router <=5 is dropped\n   * this logic is no longer needed. We can just\n   * assume back() is available.\n   */\n  handleNativeBack() {\n    const history = this.props.history as any;\n    const goBack = history.goBack || history.back;\n    goBack();\n  }\n\n  handleNavigate(\n    path: string,\n    routeAction: RouteAction,\n    routeDirection?: RouterDirection,\n    routeAnimation?: AnimationBuilder,\n    routeOptions?: any,\n    tab?: string\n  ) {\n    this.incomingRouteParams = Object.assign(this.incomingRouteParams || {}, {\n      routeAction,\n      routeDirection,\n      routeOptions,\n      routeAnimation,\n      tab,\n    });\n\n    if (routeAction === 'push') {\n      this.props.history.push(path);\n    } else {\n      this.props.history.replace(path);\n    }\n  }\n\n  handleNavigateBack(defaultHref: string | RouteInfo = '/', routeAnimation?: AnimationBuilder) {\n    const config = getConfig();\n    defaultHref = defaultHref ? defaultHref : config && config.get('backButtonDefaultHref' as any);\n    const routeInfo = this.locationHistory.current();\n    if (routeInfo && routeInfo.pushedByRoute) {\n      const prevInfo = this.locationHistory.findLastLocation(routeInfo);\n      if (prevInfo) {\n        this.incomingRouteParams = {\n          ...prevInfo,\n          routeAction: 'pop',\n          routeDirection: 'back',\n          routeAnimation: routeAnimation || routeInfo.routeAnimation,\n        };\n        if (\n          routeInfo.lastPathname === routeInfo.pushedByRoute ||\n          (\n            /**\n             * We need to exclude tab switches/tab\n             * context changes here because tabbed\n             * navigation is not linear, but router.back()\n             * will go back in a linear fashion.\n             */\n            prevInfo.pathname === routeInfo.pushedByRoute &&\n            routeInfo.tab === '' && prevInfo.tab === ''\n          )\n        ) {\n          /**\n           * history@4.x uses goBack(), history@5.x uses back()\n           * TODO: If support for React Router <=5 is dropped\n           * this logic is no longer needed. We can just\n           * assume back() is available.\n           */\n          const history = this.props.history as any;\n          const goBack = history.goBack || history.back;\n          goBack();\n        } else {\n          this.handleNavigate(prevInfo.pathname + (prevInfo.search || ''), 'pop', 'back');\n        }\n      } else {\n        this.handleNavigate(defaultHref as string, 'pop', 'back');\n      }\n    } else {\n      this.handleNavigate(defaultHref as string, 'pop', 'back');\n    }\n  }\n\n  handleResetTab(tab: string, originalHref: string, originalRouteOptions: any) {\n    const routeInfo = this.locationHistory.getFirstRouteInfoForTab(tab);\n    if (routeInfo) {\n      const newRouteInfo = { ...routeInfo };\n      newRouteInfo.pathname = originalHref;\n      newRouteInfo.routeOptions = originalRouteOptions;\n      this.incomingRouteParams = { ...newRouteInfo, routeAction: 'pop', routeDirection: 'back' };\n      this.props.history.push(newRouteInfo.pathname + (newRouteInfo.search || ''));\n    }\n  }\n\n  handleSetCurrentTab(tab: string) {\n    this.currentTab = tab;\n    const ri = { ...this.locationHistory.current() };\n    if (ri.tab !== tab) {\n      ri.tab = tab;\n      this.locationHistory.update(ri);\n    }\n  }\n\n  render() {\n    return (\n      <RouteManagerContext.Provider value={this.routeMangerContextState}>\n        <NavManager\n          ionRoute={IonRouteInner}\n          ionRedirect={{}}\n          stackManager={StackManager}\n          routeInfo={this.state.routeInfo!}\n          onNativeBack={this.handleNativeBack}\n          onNavigateBack={this.handleNavigateBack}\n          onNavigate={this.handleNavigate}\n          onSetCurrentTab={this.handleSetCurrentTab}\n          onChangeTab={this.handleChangeTab}\n          onResetTab={this.handleResetTab}\n          locationHistory={this.locationHistory}\n        >\n          {this.props.children}\n        </NavManager>\n      </RouteManagerContext.Provider>\n    );\n  }\n}\n\nexport const IonRouter = withRouter(IonRouterInner);\nIonRouter.displayName = 'IonRouter';\n","import {\n  Action as HistoryAction,\n  History,\n  Location as HistoryLocation,\n  createBrowserHistory as createHistory,\n} from 'history';\nimport React from 'react';\nimport { BrowserRouterProps, Router } from 'react-router-dom';\n\nimport { IonRouter } from './IonRouter';\n\ninterface IonReactRouterProps extends BrowserRouterProps {\n  history?: History;\n}\n\nexport class IonReactRouter extends React.Component<IonReactRouterProps> {\n  historyListenHandler?: (location: HistoryLocation, action: HistoryAction) => void;\n  history: History;\n\n  constructor(props: IonReactRouterProps) {\n    super(props);\n    const { history, ...rest } = props;\n    this.history = history || createHistory(rest);\n    this.history.listen(this.handleHistoryChange.bind(this));\n    this.registerHistoryListener = this.registerHistoryListener.bind(this);\n  }\n\n /**\n  * history@4.x passes separate location and action\n  * params. history@5.x passes location and action\n  * together as a single object.\n  * TODO: If support for React Router <=5 is dropped\n  * this logic is no longer needed. We can just assume\n  * a single object with both location and action.\n  */\n  handleHistoryChange(location: HistoryLocation, action: HistoryAction) {\n   const locationValue = (location as any).location || location;\n   const actionValue = (location as any).action || action;\n   if (this.historyListenHandler) {\n     this.historyListenHandler(locationValue, actionValue);\n   }\n }\n\n  registerHistoryListener(cb: (location: HistoryLocation, action: HistoryAction) => void) {\n    this.historyListenHandler = cb;\n  }\n\n  render() {\n    const { children, ...props } = this.props;\n    return (\n      <Router history={this.history} {...props}>\n        <IonRouter registerHistoryListener={this.registerHistoryListener}>{children}</IonRouter>\n      </Router>\n    );\n  }\n}\n","import { Action as HistoryAction, Location as HistoryLocation, MemoryHistory } from 'history';\nimport React from 'react';\nimport { MemoryRouterProps, Router } from 'react-router';\n\nimport { IonRouter } from './IonRouter';\n\ninterface IonReactMemoryRouterProps extends MemoryRouterProps {\n  history: MemoryHistory;\n}\n\nexport class IonReactMemoryRouter extends React.Component<IonReactMemoryRouterProps> {\n  history: MemoryHistory;\n  historyListenHandler?: (location: HistoryLocation, action: HistoryAction) => void;\n\n  constructor(props: IonReactMemoryRouterProps) {\n    super(props);\n    this.history = props.history;\n    this.history.listen(this.handleHistoryChange.bind(this));\n    this.registerHistoryListener = this.registerHistoryListener.bind(this);\n  }\n\n  /**\n   * history@4.x passes separate location and action\n   * params. history@5.x passes location and action\n   * together as a single object.\n   * TODO: If support for React Router <=5 is dropped\n   * this logic is no longer needed. We can just assume\n   * a single object with both location and action.\n   */\n  handleHistoryChange(location: HistoryLocation, action: HistoryAction) {\n    const locationValue = (location as any).location || location;\n    const actionValue = (location as any).action || action;\n    if (this.historyListenHandler) {\n      this.historyListenHandler(locationValue, actionValue);\n    }\n  }\n\n  registerHistoryListener(cb: (location: HistoryLocation, action: HistoryAction) => void) {\n    this.historyListenHandler = cb;\n  }\n\n  render() {\n    const { children, ...props } = this.props;\n    return (\n      <Router {...props}>\n        <IonRouter registerHistoryListener={this.registerHistoryListener}>{children}</IonRouter>\n      </Router>\n    );\n  }\n}\n","import {\n  Action as HistoryAction,\n  History,\n  Location as HistoryLocation,\n  createHashHistory as createHistory,\n} from 'history';\nimport React from 'react';\nimport { BrowserRouterProps, Router } from 'react-router-dom';\n\nimport { IonRouter } from './IonRouter';\n\ninterface IonReactHashRouterProps extends BrowserRouterProps {\n  history?: History;\n}\n\nexport class IonReactHashRouter extends React.Component<IonReactHashRouterProps> {\n  history: History;\n  historyListenHandler?: (location: HistoryLocation, action: HistoryAction) => void;\n\n  constructor(props: IonReactHashRouterProps) {\n    super(props);\n    const { history, ...rest } = props;\n    this.history = history || createHistory(rest);\n    this.history.listen(this.handleHistoryChange.bind(this));\n    this.registerHistoryListener = this.registerHistoryListener.bind(this);\n  }\n\n  /**\n   * history@4.x passes separate location and action\n   * params. history@5.x passes location and action\n   * together as a single object.\n   * TODO: If support for React Router <=5 is dropped\n   * this logic is no longer needed. We can just assume\n   * a single object with both location and action.\n   */\n  handleHistoryChange(location: HistoryLocation, action: HistoryAction) {\n    const locationValue = (location as any).location || location;\n    const actionValue = (location as any).action || action;\n    if (this.historyListenHandler) {\n      this.historyListenHandler(locationValue, actionValue);\n    }\n  }\n\n  registerHistoryListener(cb: (location: HistoryLocation, action: HistoryAction) => void) {\n    this.historyListenHandler = cb;\n  }\n\n  render() {\n    const { children, ...props } = this.props;\n    return (\n      <Router history={this.history} {...props}>\n        <IonRouter registerHistoryListener={this.registerHistoryListener}>{children}</IonRouter>\n      </Router>\n    );\n  }\n}\n"]},"metadata":{},"sourceType":"module"}